# Effective-C-Plus-Plus-Study
이펙티브 C++ 3판을 읽고 공부한 내용들 입니다.

정리 현황 (Bold 되어있는 챕터들은 정리가 끝난 챕터들 입니다.)  
__0. Effective C++의 목적__  
__1. C++의 법__  
2. 생성자, 소멸자, 대입연산자  (정리중)  
~~3. 자원관리~~  
__4. 설계 및 선언__  
__5. 구현__   
__6. 객체 지향 설계__  
~~7. 템플릿과 일반화 프로그래밍~~  
~~8. new와 delete~~ 


## 목차  
0. Effective C++의 목적
1. C++의 법 
    - C++을 언어들의 연합체로 바라보는 안목
    - #define을 쓸 때는 const, enum, inline을 먼저 떠올리자
    - const의 활용
    - 객체를 사용하기 전에 반드시 사용할 객체를 초기화 하자
2. 생성자, 소멸자, 대입연산자
    - C++이 자동으로 만드는 함수들
    - 컴파일러가 만들어낸 함수가 필요없다면 금지해버리자
    - 다형성을 가진 기본 클래스에서는 반드시 가상 소멸자로 선언
    - 예외가 소멸자를 떠나지 못하도록 잡아두자
    - 객체 생성 및 소멸 과정 중에는 절대로 가상 함수를 호출하지 말자.
    - 대입 연산자는 *this의 참조자를 반환하게 하자.
    - operator=에서는 자기대입에 대한 처리가 빠지지 않도록 하자
    - 객체의 모든 부분을 빠짐없이 복사하자
3. 자원관리
    - 자원관리를 위해 객체를 사용
    - 자원관리 클래스의 복사 동작
    - 자원관리 클래스에서 관리되는 자원은 외부 접근이 가능하게 하자
    - new, delete 사용 시 반드시 형태를 맞추자
    - new 로 생성한 객체를 스마트 포인터에 저장하는 코드는 별도의 한 문장으로 만들자
4. 설계 및 선언
    - 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게
    - 클래스 설계는 타입 설계와 똑같이 취급
    - pass-by-value 보다는 const reference에 의한 전달방식이 보통 좋다.
    - 함수에서 객체를 반환할 때 참조자를 반환하지 말자
    - 데이터 멤버는 private에 선언
    - 비멤버 비프렌드 함수를 자주 쓰자.
    - 타입 변환이 모든 매개변수에 대해 적용되어야 한다면 비멤버 함수로 선언
    - 예외를 던지지 않는 swap에 대한 지원
5. 구현 
    - 변수 정의는 최대한 늦추자
    - 캐스팅은 최대한 절약
    - 내부에서 사용하는 객체에 대한 handle을 반환하는 코드는 피하자
    - 예외 안정성을 최대한 확보하자.
    - 인라인 함수를 잘 알아두자
    - 파일 사이의 컴파일 의존성을 최대한 줄이자
6. 객체 지향 설계
    - public 상속 모형은 반드시 "is-a(~는~의 일종이다)"를 따르도록 만들자
    - 상속된 이름을 숨기는 일은 피하자
    - 인터페이스 상속과 구현 상속
    - 가상 함수 대신 사용 할 수 있는 것
    - 상속받은 비가상 함수를 파생 클래스에서 재정의하지 말자
    - 어떤 함수에 대해서도 상속받은 기본 매개변수 값은 재정의하지 말자
    - has-a 와 is-implemented-in-terms-of를 구현할때는 객체합성을 사용하자
    - private 상속은 심사숙고해서 사용하자
    - 다중 상속은 심사숙고해서 사용하자
7. 템플릿과 일반화 프로그래밍
    - 암시적 인터페이스와 컴파일 타임 다형성