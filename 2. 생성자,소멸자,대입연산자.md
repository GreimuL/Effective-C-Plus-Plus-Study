# 생성자, 소멸자, 대입연산자
## C++이 자동으로 만드는 함수들
- 컴파일러가 클래스 안에 넣지 않은 함수를 자동으로 선언해주는 경우가있음
    - 기본 생성자
    - 복사 생성자
    - 복사 대입 연산자
    - 소멸자
- 복사 대입 연산자의 경우 클래스 멤버 변수로 참조자가 있다면 자동으로 생성되지 않음
    - 참조자는 원래 자신이 참조하고 있는 것과 다른 객체를 참조할 수 없기 때문

## 컴파일러가 만들어낸 함수가 필요없다면 금지해버리자
- 예를 들면 사본을 막고 싶을 때 사용가능
- 대응되는 멤버 함수를 private로 선언
    - 다만 이러면 컴파일 시점 에러가 아닌 링크 시점 에러가 발생하기에, 복사를 금하는 역할을 하는 base 클래스를 따로 만들어서 상속하는것이 좋음    

## 다형성을 가진 기본 클래스에서는 반드시 가상 소멸자로 선언
```C++
//Base 클래스를 상속받는 클래스 A를 Base 포인터를 이용하여 delete 하는 상황
A* a = new A();
Base* base = (Base*)a;
delete base;
```
- 위와 같은경우 Base 클래스의 소멸자가 가상 소멸자가 아니라면 클래스 A의 소멸자가 호출이 안되어서 메모리 누수 발생 가능

## 예외가 소멸자를 떠나지 못하도록 잡아두자
- 소멸자에서 예외가 발생한다면 어떻게든 소멸자 안에서 끝내야함
    - 소멸자에서 예외가 발생하면 UB의 가능성이 큼
    - 프로그램을 끝내거나
    - 예외를 삼키거나 처리
    - 사용자에게 예외처리의 기회를 주려면 일반함수에서 처리

## 객체 생성 및 소멸 과정 중에는 절대로 가상 함수를 호출하지 말자.
- 파생 클래스 객체를 생성할 때 그 객체의 기본 클래스 부분이 먼저 호출된다.
- 기본 클래스의 생성자에 가상 함수를 넣게되면, 파생 클래스의 것이 아닌 기본클래스의 함수가 실행된다.
- 기본클래스의 생성자가 호출될 동안에는 가상 함수가 절대로 파생 클래스 쪽으로 내려가지 않는다.

## 대입 연산자는 *this의 참조자를 반환하게 하자.
- 관례 같은 느낌
## operator=에서는 자기대입에 대한 처리가 빠지지 않도록 하자
- 자기대입 문제 해결 방법
    - 원본 객체와 복사대상 객체의 주소 비교
    - Copy and swap
- 두개 이상의 객체에 대해 동작하는 함수가 있을 때, 객체들이 같은 객체인 경우를 고려해야함

## 객체의 모든 부분을 빠짐없이 복사하자
- 두가지를 생각
    - 해당 클래스의 데이터 멤버를 모두 복사
    - 이 클래스가 상속한 기본 클래스의 복사 함수도 호출