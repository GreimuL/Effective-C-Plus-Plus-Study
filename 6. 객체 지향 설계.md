# 객체 지향 설계
## public 상속 모형은 반드시 "is-a(~는~의 일종이다)"를 따르도록 만들자
- public 상속은 기본 클래스 객체가 가진 모든 것들이 파생 클래스 객체에도 그대로 적용된다고 단정하는 상속. 
## 상속된 이름을 숨기는 일은 피하자
- 파생 클래스에서 선언한 이름은 기본 클래스의 이름을 가린다.
- public 상속에서 이름이 가려지는 일은 바람직하지않다.
- using 선언을 사용하거나 전달함수(forwarding function)을 통해 가려진 이름을 다시 볼 수 있다.
## 인터페이스 상속과 구현 상속
```C++
virtual void foo(); //가상 함수
virtual void foo() = 0; //순수 가상 함수
void foo(); //비 가상 함수
```
- 순수 가상 함수의 목적은 파생 클래스에게 함수의 인터페이스만을 물려주기 위함
    - 필요에 따라서 순수 가상 함수에도 구현을 붙일 수 있다.  
    대신 호출할 때, 클래스 이름을 한정자로 붙여 주어야한다. (ex)Cls::Foo()
- 단순 가상 함수의 목적은 파생 클래스에게 (함수의 인터페이스 + 함수의 기본 구현)을 물려주기 위함.  
필요에 따라서 재 정의 하거나 기본 구현 사용가능.
- 비 가상 함수의 목적은 파생 클래스에게 (함수 인터페이스 + 함수의 필수적인 구현)을 물려받게 하기 위함.  
즉, 클래스 파생에 상관없이 변하지 않는 동작을 지정