# C++의 법
C++의 가장 근본적인 것들을 다루고 있는 챕터

## C++을 언어들의 연합체로 바라보는 안목
- C++ = 다중 패러다임 프로그래밍 언어  
절차적, 객체 지향, 함수형, 일반화 프로그래밍 + 메타프로그래밍 개념 지원
- C++은 4가지의 하위 언어를 제공  
C, 객체 지향 개념의 C++, 템플릿 C++, STL
- C++의 어떤 부분을 사용하느냐에 따라서 사용할 수 있는 효과적인 규칙이 달라진다.  

## #define을 쓸 때는 const, enum, inline을 먼저 떠올리자
- define으로 만든 이름은 심볼테이블로 넘어가지 않기 때문에 에러가 발생할 경우 이름이 나오지 않아서 곤란해질 수 있다.
    - 매크로 대신 const를 쓰자.
- 대문자 표기 이름은 보통 매크로에서만 사용하므로 const로 바꿀 때는 표기를 바꿔준다.
- 상수가 부동소수점 실수 타입일 경우는 매크로를 사용한 경우보다 const를 사용했을 때 컴파일 된 최종 코드의 길이가 더 작게 나올 수 있다.
    - 매크로를 쓰면 전처리기에 의해서 목적 코드 안에 교체하려는 수의 사본이 나오는 횟수만큼 들어가게 되지만, const의 경우는 아무리 여러 번 쓰여도 사본이 딱 한개만 생기기 때문이다.  
- 상수 포인터를 선언하는 경우에는 포인터와 포인터가 가리키는 대상 모두 const로 선언하는 것이 일반적이다.  
- 클래스 멤버로 상수를 정의하는 경우(상수의 접근 범위를 클래스로 한정하기 위함)에 그 상수가 단 하나만 존재하게 하고 싶을 때는 static 멤버로 만들어야 한다.  
- 정수 타입의 정적 클래스 상수에 대한 클래스 내 초기화를 금지하는 경우 enum hack을 사용할 수 있다.
```C++
//enum hack
class GamePlayer{
  private:
  enum{Num = 5};
  int scores[Num];
}
```
- enum hack의 장점
    - enum hack 의 동작 방식은 #define에 가깝다.
    - 만약 자신이 선언한 정수 상수를 다른 사람이 주소를 얻거나 참조자를 쓰는것을 원치 않을 경우 enum hack으로 막을 수 있다.  
    - 생각보다 많이 쓰이는 기법이라 알아두면 좋다. (템플릿 메타프로그래밍의 핵심 기법)
- 매크로 함수 보다는 inline 함수에 대한 템플릿을 사용하면 더 좋다.
```C++ 
//매크로
#define CALL_WITH_MAX(a,b) f((a)>(b)?(a):(b))
//inline 함수 템플릿
template<typename T>
inline void callWithMax(const T& a, const T& b){ f(a>b?a:b); }
```   

## const의 활용  
```C++
char *p = str;  //비상수 포인터, 비상수 데이터
const char *p = str;    //비상수 포인터, 상수 데이터
char * const p = str;   //상수 포인터, 비상수 데이터
const char * const p = str; //상수 포인터, 상수 데이터
```  
- const키워드가 *의 왼쪽에 있으면 포인터가 가리키는 대상이 상수   
const가 *의 오른쪽에 있는 경우엔 포인터 자체가 상수  
- STL iterator를 const로 선언하는 것은 T* const 포인터와 같은 효과이다.
- STL iterator를 const T* 처럼 사용하고 싶으면 const_iterator를 사용하면 된다. 
- 함수 반환 값을 상수로 정하는 좋은 예시  
```C++
const Cls1 operator*(const Cls1& lhs, const Cls1& rhs);

Cls1 a,b,c;
if(a*b = c){}   // '=='을 '='으로 치는 실수를 했음에도 에러가 생기지 않는다.
```
- operator*의 반환값을 상수 객체로 선언해주면, 위와 같은 실수를 미연에 방지할 수 있다.  
그러므로 가능하다면, 함수의 반환값 및 매개변수를 최대한 const로 사용하는 것이 좋다.  
- 멤버 함수에서 const의 의미 : 해당 멤버 함수가 상수 객체에 대해 호출될 함수라는 것을 의미
- 상수 상태로 전달된 객체를 조작하려면 상수 멤버함수가 있어야함  
- const가 있고 없고 차이만 있는 멤버 함수들은 오버로딩이 가능하다.  
```C++
class Cls{
public:
    const char& operator[](size_t position) const {}
    char& operator[](size_t position){}
}
```


## 객체를 사용하기 전에 반드시 사용할 객체를 초기화 하자  



## 요약 정리  
- 단순한 상수를 사용할 때는 #define 보다 const 객체나 enum을 우선으로 생각한다.
- 매크로 함수보다는 inline 함수를 먼저 생각한다.